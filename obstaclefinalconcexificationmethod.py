# -*- coding: utf-8 -*-
"""ObstacleFinalConcexificationMethod.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16kQTD3V9ILSMoZ9jdW_wK8ljWNdcL5FY

Class that linearize and discretize a model arounf a point
"""

#import library
from sympy import symbols, IndexedBase, Idx
import sympy as sp
import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
#from scipy.misc import derivative
from sympy import *

class DiscretizeandLinearizeGeneric():
  def __init__(self,Z,xhat,uhat,n):
    #matrix A of states linearize 
        self.Aj = np.zeros(shape= (x[n_states].shape[0],x[n_states].shape[0]))     
        #matrix B of input linearize
        self.Bj = np.zeros(shape= (x[n_states].shape[0],u[n_in].shape[0]))
        #point around that we will make the linearization 
        self.xhat = xhat[:]
        self.uhat = uhat[:]
        #equation of states (ODE)
        self.Z = Z
        #matrix of the difference between the real equation and the linearize one
        self.p = []
        #matrix of the discretize system
        self.Ad=[]
        self.Bd=[]
        self.Cd=[]
        #list of matrix discrete to make the convex opt
        self.Ad_list = [None]*(n-1)
        self.Bd_list = [None]*(n-1)
        self.Cd_list = [None]*(n-1)

  def evaluatePerte(self):
      dxdt = self.Z[:]
      #linearize the A matrix with symbols
      xhat = self.xhat
      uhat = self.uhat
      #evaluate the real system around the point xhat,uhat
      for c in range(len(dxdt)):
        for i in range(len(xhat)):
            dxdt[c] = dxdt[c].subs(x[i],xhat[i])
        for i in range(len(uhat)):
            dxdt[c]= dxdt[c].subs(u[i],uhat[i])
      #save the result inside a matrix
      #p will be the waste of the linearize system
      self.p = -self.p + dxdt[:]

      #class that calculate the matrix A and B jacobien and make the evaluation around the points xhat and uhat 
  def JacobianAndEvaluate(self):
      dxdt = self.Z[:]
      #linearize the A matrix with symbols
      xhat = self.xhat
      uhat = self.uhat
      #linearize the A matrix with symbols
      for c in range (len(dxdt)):
        for h in range (x[n_states].shape[0]):
          #calculate the derivative of the c ode of the x[h] variable of states
          A = sp.diff(dxdt[c],x[h])
          for i in range(len(xhat)):
            A = A.subs(x[i],xhat[i])
          for i in range(len(uhat)):
            A = A.subs(u[i],uhat[i])
          self.Aj[c][h] = A
      #self.Aj = np.array([[sp.diff(dx1dt,x[0]),sp.diff(dx1dt,x[1]),sp.diff(dx1dt,x[2])],[sp.diff(dx2dt,x[0]),sp.diff(dx2dt,x[1]),sp.diff(dx2dt,x[2])],[sp.diff(dx3dt,x[0]),sp.diff(dx3dt,x[1]),sp.diff(dx3dt,x[2])]])
      #linearize B matrix with symbols
      for c in range (len(dxdt)):
        for h in range (u[n_in].shape[0]):
          #calculate the B matrix making the derivative of ode respect to the inputs
          B = sp.diff(dxdt[c],u[h])
          for i in range(len(xhat)):
            B = B.subs(x[i],xhat[i])
          for i in range(len(uhat)):
            B = B.subs(u[i],uhat[i])
          self.Bj[c][h] = B
      #self.Bj = np.array([[sp.diff(dx1dt,u[0]),sp.diff(dx1dt,u[1])],[sp.diff(dx2dt,u[0]),sp.diff(dx2dt,u[1])],[sp.diff(dx3dt,u[0]),sp.diff(dx3dt,u[1])]])
      #print(self.Bj)
      #pass the information of the evaluation of the equation to evaluate the waste between the linear and non linear system
      self.p = np.dot(self.Bj,uhat) + np.dot(self.Aj,xhat)
      self.evaluatePerte()

  def mod_point(self,xhat,uhat):
    #calculate the matrix of the system to make the discretization 
        self.xhat = xhat[:]
        self.uhat = uhat[:]
        self.JacobianAndEvaluate()
  
  def lin2disc(self,xhat,uhat,n,dt):
        #discretize the system 
        self.mod_point(xhat,uhat)
        resolution = 100
        Adx_list = [None] * (resolution+1)
        Adr_list = [None] * (resolution+1)
        Adx_list[0] = np.eye(x[n_states].shape[0])
        Adr_list[0] = np.eye(x[n_states].shape[0])
        delta=dt/resolution
        for i in range(resolution):
          Adx_list[i+1] = Adx_list[i] + np.dot(Adx_list[i],self.Aj)*delta
          Adr_list[i+1] = Adr_list[i] - np.dot(Adr_list[i],self.Aj)*delta
        self.Ad = Adx_list[resolution]
        self.Bd = np.zeros([x[n_states].shape[0],u[n_in].shape[0]])
        self.Cd = np.zeros([x[n_states].shape[0],])
        #self.p = np.reshape(self.p,(3,1))
        #print(self.p)
        for i in range(resolution):
          Ard = Adr_list[i+1]
          self.Bd = self.Bd + (np.dot(Ard,self.Bj)*delta)
          self.Cd = self.Cd + (np.dot(Ard,self.p)*delta)
        self.Bd = np.dot(self.Ad,self.Bd)
        self.Cd = np.dot(self.Ad,self.Cd)
        #print(self.Ad)
        #print(self.Bd)
        #print(self.Cd)
        return self.Ad,self.Bd,self.Cd


  def disc(self,uw,n,dt,x_ss):
    #evaluate the system discrete 
      tf = dt*n 
      t = np.linspace(0,tf,n)
        # store solution
      xk = np.zeros(shape =(x[n_states].shape[0],n))
      # record initial conditions
      xk[:,0] = x_ss
      for i in range(1,n):
          u0 = uw[:,i-1]
          x0 = xk[:,i-1]
          #calculate the discrete matrix around the points x0 and u0
          self.Ad_list[i-1],self.Bd_list[i-1],self.Cd_list[i-1] = self.lin2disc(x0,u0,n,dt)
          #store solutions
          xk[:,i] = np.dot(self.Ad,x0)+np.dot(self.Bd,u0) + self.Cd 
      return xk 
      
  def get_list(self):
    return np.array(self.Ad_list).astype(np.float64),np.array(self.Bd_list).astype(np.float64),np.array(self.Cd_list).astype(np.float64)

"""Class that provide the calculation of CVX method to generate a trajectory

TRY TO create an obstacle to be avoided at 0.5 , 0.5 but not working with linear or quadratic constrains
"""

# Import packages.
import cvxpy as cp
import numpy as np

class ConvexOpt():
  def __init__(self,N,x_init,x_fin,u_in,A_list,B_list,C_list,xante,uante,p):
    #init the variables of the class
    self.N = N
    self.x_init = x_init
    self.x_fin = x_fin
    self.u_in = u_in
    self.Ad_list = A_list
    self.Bd_list = B_list
    self.Cd_list = C_list
    self.xante = xante
    self.uante = uante
    self.p = p
    
  def CVXOPT(self,opt_power = False,opt_velocity = False):
    #save the number of states and inputs
    x_len =(int) (x[n_states].shape[0])
    u_len = (int) (u[n_in].shape[0])
    #define the variables to be evaluate 
    xv = cp.Variable(shape=(x_len, self.N))
    uv = cp.Variable((u_len, self.N-1))
    tau = cp.Variable(shape=(self.N))
    tau_vel = cp.Variable(shape=(self.N))
    tau_u = cp.Variable(shape=(self.N-1))
    hogb = cp.Variable(self.N-1)
    hog = cp.Variable(shape = (x_len,self.N-1))
    nu = cp.Variable(1,)
    #define the objective of the convex optimization 
    obj = cp.sum_squares(np.ones(shape=(1,self.N))*tau +np.ones(shape=(1,self.N))*tau_vel + 10*np.ones(shape=(1,self.N-1))*tau_u  + np.ones(shape=(1,self.N-1))*10**3*hogb+ 10**7*nu)
    obj = cp.Minimize(obj)
    #define all constrains to be take into account but they have to be convex 
    constr = []
    #initial condition for x-y position and angular position
    constr += [xv[:,0] == self.x_init]
    #initial condition related to inputs 
    constr += [uv[:,0] == self.u_in]
    #final position constrain 
    constr += [cp.norm(xv[:,self.N-1] - self.x_fin) <= 10e-9]
    #trajectory limitation 
    for t in range(0,self.N-1):
      #discrete trajectory with virtual control 
        constr += [ xv[:,t+1] == self.Ad_list[t]@xv[:,t] + self.Bd_list[t] @ uv[:,t] + self.Cd_list[t]]
        #norm(hog(:,k)) <= hogb(k)
        constr += [cp.norm(hog[:,t]) <= hogb[t]]

    #take into account only the shortest trajectory 
        #constr += [cp.norm(xv[:,t-1] - xv[:,t]) <= tau[t]]

        #I tried to code linear obstacle but  working only in rectangular case  
        #constr += [xv[1,t] <= 6]
        #constr += [xv[1,t] >= 0]
        #constr += [xv[0,t] <= 5] 
        #constr += [cp.norm2(xv[0,t] - 1) >= 1]

        #contrainte qui definit la presence d'un obstacle
        #position
        H = np.array([[1,0],[0,1]], dtype=float) #geometrie
        if np.any(self.xante) and np.any(self.uante): #contrainte qui vient de la thÃ¨se de Miki
            A = H
            b = np.dot(H,self.p)
            v = np.dot(H,self.xante[:2,t]) - b
            f = cp.norm2(v)
            constr += [nu >= 0]
            constr += [f+np.transpose(A@v)@(xv[:2,t]-self.xante[:2,t])/f >= 1 - nu]
            constr += [cp.norm(self.xante[:,t]-xv[:,t]) <= tau[t]]  #contrainte de distance entre deux points de deux iterations successives
    #limit the final velocity    
    constr += [cp.norm(uv[:,self.N-2]) <= 10e-9]
    #contrain of the velocity of convergence to the final point % ||target - x_k||_2 <= taui_k
    if(opt_velocity):
      for t in range (0,self.N-1):
        constr += [cp.norm2(xv[:,t] - self.x_fin)<= tau_vel[t]]
    #constrain to optimize the power efficency related to the norm of u
    if(opt_power):
      for t in range (0,self.N-2):
        constr += [cp.norm(uv[:,t]) <= tau_u[t]]

    #resolve the problem    
    prob = cp.Problem(obj , constr)
    prob.solve(solver = cp.SCS,verbose=True)
    xv = np.array(xv.value)
    uv = np.array(uv.value)
    return xv,uv

"""LEt' s combine the two classes"""

from sympy import symbols, IndexedBase, Idx
import sympy as sp
import numpy as np
import time 
from sympy import *
import matplotlib.patches as pat

#let's define the variables of the class (u inputs and x states)
u = IndexedBase('u')
n_in = symbols('n_in ', integer=True)
u[n_in]
#you can change the number of input but not the name
n_in = Idx('n_in', 2)
x = IndexedBase('x')
n_states = symbols('n_states', integer=True)
x[n_states]
#You can change the number of states not the name
n_states = Idx('n_states', 3)

# steady state conditions
x_init = [0,0,0]
u_ss = [1,1]
# final time
tf = 10 #(seconds)
#resolution
k = 1
# number of time points
n = tf * k + 1      #total points
# time points
dt = tf/n
t = np.linspace(0,tf,n)

#define the ode of the system
Z = [(.16/2)*(u[0]+u[1])*sp.cos((3.14/180)*x[2]),(.16/2)*(u[0]+u[1])*sp.sin((3.14/180)*x[2]),(.16/.55)*(u[0]-u[1])]
eq = DiscretizeandLinearizeGeneric(Z,np.zeros(x[n_states].shape[0]),np.ones(u[n_in].shape[0]),n)

# define inputs over time 
u1= np.ones(n) * u_ss[0]
u2= np.ones(n) * u_ss[1]
uw = np.array( [u1,u2])
#define the goal  position and the condition initial of the velocity
x_fin = [4,4,60]
u_in = [0,0]
#set the start time 
start = time.time()
# Some times to record each part
time_disc = 0
time_cvx = 0
x_len = len(x_init)
uante = [[None] * x_len * n]
xante = [[None] * x_len * n]
traj_fin = [[None]*x_len ]
p = np.array([2,2]) 
#iteration to find the optimum result
for i in range (20):
  st = time.time ()
  #resolution discrete sistem
  x1,x2,x3 = eq.disc(uw,n,dt,x_init)
  Ad_list,Bd_list,Cd_list = eq.get_list()
  time_disc += (time.time () - st) 
  #call the Convex optimization class to resolve the problem 
  st = time.time ()
  cvx = ConvexOpt(n,x_init,x_fin,u_in,Ad_list,Bd_list,Cd_list,xante,uante,p)
  #tell to optimize the power 
  opt_pow = True
  #tell to optimize the rapidity of convergence
  opt_conv = True
  xout,uout = cvx.CVXOPT(opt_pow,opt_conv)
  uw = uout
  time_cvx += (time.time () - st) 
  uante = np.copy(uout)
  xante = np.copy(xout)
  #plot the results 
  print("Results of the convexification number :",i+1)
  plt.plot(xout[0],label='x1(t) with hog')
  plt.plot(x1,label='x1(t) real')
  plt.legend(loc='best')
  plt.show()
  plt.plot(xout[1],label='x2(t) with hog')
  plt.plot(x2,label='x2(t) real')
  plt.legend(loc='best')
  plt.show()
  plt.plot(xout[2],label='x3(t) with hog')
  plt.plot(x3,label='x3(t) real')
  plt.legend(loc='best')
  plt.show()
  plt.plot(uw[0],label='u1(t)')
  plt.plot(uw[1],label='u2(t)')
  plt.legend(loc='best')
  plt.show()
  #obstacle affiche 
  c = pat.Circle((2,2), 1, fill = False)
  plt.gcf().gca().add_artist(c) 
  plt.plot(xout[0], xout[1], label="traj")
  plt.show()
  traj_fin = xout

done = time.time()
#plot the true trajectory calculated take into account the estimated u vector with cvx optimization
x1,x2,x3 = eq.disc(uw,n,dt,x_init)
print("Real trajectory with calculated u signal")
plt.figure(1)
plt.subplot(3,1,1)
plt.plot(t,x1,'b-',linewidth=3,label='x1(t) real')
plt.plot(t,traj_fin[0],'r-',linewidth=3,label='x1(t) hog')
plt.xlabel('time')
plt.grid()
plt.legend(loc='best')
plt.subplot(3,1,2)
plt.plot(t,x2,'r-',linewidth=3,label='x2(t) real')
plt.plot(t,traj_fin[1],'b-',linewidth=3,label='x2(t) hog')
plt.xlabel('time')
plt.legend(loc='best')
plt.grid()
plt.subplot(3,1,3)
plt.plot(t,x3,'b-',linewidth=3,label='x3(t) real')
plt.plot(t,traj_fin[2],'r-',linewidth=3,label='x3(t) hog')
plt.xlabel('time')
plt.grid()
plt.legend(loc='best')
plt.show()

plt.subplot(3,1,1)
plt.plot(uw[0],'b-',linewidth=3,label='u1(t)')
plt.xlabel('time')
plt.grid()
plt.legend(loc='best')
plt.subplot(3,1,2)
plt.plot(uw[1],'b-',linewidth=3,label='u2(t)')
plt.xlabel('time')
plt.grid()
plt.legend(loc='best')
plt.subplot(3,1,3)
plt.plot(x1,x2,'b-',linewidth=3,label='x-y plot')
plt.plot(traj_fin[0],traj_fin[1],'r-',linewidth=3,label='x-y plot hog')
plt.xlabel('x')
plt.grid()
plt.legend(loc='best')
plt.show()
print("time passed to calculate the trajectory [seconds]:=")
elapsed = done - start
print(elapsed)
print("time disc:=")
print(time_disc)
print("time cvx:=")
print(time_cvx)